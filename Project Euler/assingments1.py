import math
from timeit import default_timer as timer


""" Exercise 1:Multiples of 3 and 5(from Project Euler 1)If we list all the natural numbers
below 10 that are multiples of 3 or 5, we get 3, 5, 6 and9.  The sum of these multiples is 23.
→Find the sum of all the multiples of 3 or 5 below 1000."""

def count_three_five(upto):
    n = 0
    for i in range(0, upto):
        if i%5 == 0 or i%3 == 0:
            n += i
    print("sum of multiples of 3 or 5 smaller than", upto, ": ", n)
    return n


"""Exercise 2:Euclidian algorithm. The Euclidian algorithm can be used to find the
greatest common divisor(GCD) of two numbers, in an efficient way.The algorithm is as follows (in python):"""


def gcd(a, b):
    a, b = abs(a), abs(b)
    while b != 0:
        a, b = b, a % b
    return a


def lcm(a, b):
    return a*b // gcd(a, b)


def frac(a, b):
    g = gcd(a, b)
    numerator = a / g
    denominator = b / g
    if denominator == 1:
        print("the fraction %d/%d reduces to: %d" % (a, b, numerator))
    else:
        print("the fraction %d/%d reduces to: %d/%d" % (a, b, numerator, denominator))
    return [numerator, denominator]

def bezout_coefficients(a_arg, b_arg):
    a, b = abs(a_arg), abs(b_arg)
    xa, ya, xb, yb = 1, 0, 0, 1
    if b > a:
        a, b = b, abs(a_arg)
        xa, ya, xb, yb = 0, 1, 1, 0
    while b != 0:
        d = divmod(a, b)
        a, b = b, d[1]
        x, y = xb, yb
        xb = xa - d[0]*xb
        yb = ya - d[0]*yb
        xa, ya = x, y
    print("gcd: %3d = %4d (%3d)  + %4d(%3d)" % (a, xa, a_arg, ya, b_arg))
    return a


"""Exercise 3:  Different number system."""

def encode(number):
    if number < 10:
        c = chr(number + 48)
    else:
        c = chr(number + 55)
    return c


def decode(char):
    n = ord(char)
    if n < 65:
        num = n - 48
    else:
        num = n - 55
    return num


def to_k(num, k):
    arr = []
    while num != 0:
        d = divmod(num, k)
        arr.insert(0, encode(d[1]))
        num = d[0]
    string = ''.join(arr)
    return string


def from_k(string, k):
    arr = list(string)
    num = 0
    n = 0
    while len(arr) != 0:
        num += decode(arr.pop()) * (k ** n)
        n += 1
    return num

def convert(k, m ,s):
    return to_k(from_k(s,k), m)


"""Exercise 4:Fibonacci(from Project Euler 2)Each new term in the Fibonacci sequence is generated by adding the previous 
two terms.By starting with 0 and 1, the first 12 Fibonacci numbers are:0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
→By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms."""

def fibo(n):
    a, b = 0, 1
    for i in range(2, n):
        hold = b
        b += a
        a = hold
    return b


def fibo_sum_evens(n):
    sum_even = 0
    a, b = 0, 1
    for i in range(2, n):
        hold = b
        b += a
        a = hold
        if i % 3 == 0:
            sum_even += b
    return sum_even


"""Exercise 5:Palindromes(from Project Euler 4)A palindromic number reads the same both ways.  
The largest palindrome made from the product of two 2-digit numbers is 9009 = 91  99.
→ Find the largest palindrome made from the product of two 3-digit numbers.
the RESULT: palindrome 906609 has factors 993 and 913"""

def is_palindrome(num):
    result = True
    arr = list(to_k(num, 10))
    lng = len(arr)
    for i in range(0, (lng//2 + 1)):
        if arr[i] != arr[lng - 1 - i]:
            return False
    return result


def find_max(lower, upper):
    palindromes = []
    for i in range(lower, upper):
        for j in range(lower, upper):
            multiple = j * i
            if is_palindrome(multiple):
                palindromes.append(multiple)
    return palindromes

def max_elem(list):
    max = 0
    for i in range(0, len(list)):
        if list[i] > max:
            max = list[i]
    return max


"""Exercise 6:Factorials!"""

def fac(n):
    k = 0
    t = 1
    while k < n:
        k = k + 1
        t = t * k
    return t

def n_choose_k(n, k):
    return fac(n)//(fac(n - k) * fac(k))


"""Exercise 7:(Divisors and prime factors)"""

def divisors(n):
    divisors = []
    for i in range(1, n + 1):
        if n % i == 0:
            divisors.append(i)
    return divisors


def primes_up_to(n):
    i = 1
    primes = [2]
    while i < n:
        i += 2
        is_prime = True
        for j in primes:
            if i % j == 0:
                is_prime = False
                break
        if is_prime:
            primes.append(i)
    return primes


def prime_factorization1(num):
    n = num
    prime_div = primes_up_to(math.floor(math.sqrt(num)))
    factors = {}
    for i in prime_div:
        while n % i == 0:
            n = n // i
            if i in factors.keys():
                factors[i] += 1
            else:
                factors.update({i: 1})
    if n != 1:
        factors.update({n: 1})
    return factors


"""Exercise 8:(Largest prime factorsfrom Project Euler 3)
The prime factors of 13195 are 5, 7, 13 and 29.
→What is the largest prime factor of the number 600851475143?"""


def find_next_prime(primes):
    if primes == [2]:
        return [2, 3]
    else:
        i = primes[len(primes) - 1]
        found = False
        while not found:
            i += 2
            is_prime = True
            for j in primes:
                if i % j == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(i)
                found = True
    return primes


def prime_factorization2(num):
    n = num
    factors = {}
    p_div = [2]
    i = 2
    while i < math.floor(math.sqrt(n)):
        i = p_div[len(p_div) - 1]
        while n % i == 0:
            n = n // i
            if i in factors.keys():
                factors[i] += 1
            else:
                factors.update({i: 1})
        p_div = find_next_prime(p_div)
    if n != 1:
        factors.update({n: 1})
    return factors

"""Exercise 9:(Optional) Divisors(from Project Euler 5) 2520 is the smallest number that can be divided by each 
of the numbers from 1 to 10without any remainder.→What is the smallest positive number that can be divided by 
each of the numbers from 1 to 20 without any remainder?This problem can be solved using either pen and paper 
(pure mathematics), or a computer(mathematics and programming).  Try both ways! 
RESULT: 232792560"""

def find_smallest_fit(n):
    prime_fac = {}
    for i in range(2, n + 1):
        new = prime_factorization1(i)
        for j in new.keys():
            if j in prime_fac.keys() and new[j] > prime_fac[j]:
                prime_fac[j] = new[j]
            elif j not in prime_fac.keys():
                prime_fac.update({j: new[j]})
    return prime_fac

def expand(prime_fac):
    n = 1
    for i in prime_fac.keys():
        n = n * i ** prime_fac[i]
    return n


"""Exercise 10:(Optional) Prime sieve
While  checking  if  a  given  number  is  useful,  and  one  can  generate  a  few  (large)  prime numbers with it, 
other applications require all primes between 2 and a limitN.  A quick method  is  the Prime  Sieve  (of  Eratosthenes),  
which sieves the  non-prime  (composite)numbers from the range 2. . . N.  The Greek Eratosthenes found this method 240 B.C.,
and it is still the base for the most efficient prime sieves up-to-date.The algorithm in pseudo-code is as follows:"""

def eratosthenes(n):
    is_comp = {}
    for i in range(2, n + 1):
        is_comp.update({i: False})
    primes = []
    for m in range(2, n + 1):
        if not is_comp[m]:
            primes.append(m)
            for k in range(2, n//m):
                is_comp[k * m] = True
    return is_comp


"""Exercise 11"""
def testshit():
    A = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]
    A[1][2] = 99
    print(A)
    A = [[0] * 10] * 10
    print(A)
    A[1][2] = 99
    print(A)
    A = []
    for i in range(0, 10):
        A.append([0] * 10)
    print(A)
    A[1][2] = 99
    print(A)




if __name__ == '__main__':

    # count_three_five(10)
    # count_three_five(1000)
    #
    # print("gcd = ", gcd(3141, 156))
    # print("gcd = ", gcd(12345678, 987654321))
    # print("gcd = ", gcd(32, 24))
    #
    # frac(18, -6)
    # frac(-34, 18)
    # frac(-14, 266)
    #
    bezout_coefficients(2597, 1369)
    # bezout_coefficients(4, 27)
    # bezout_coefficients(32, 36)
    # bezout_coefficients(75, 100)

    print(divmod(1820, 231))
    # decode('0')
    # decode('9')
    # decode('Z')
    # print(convert(7, 10, "251"))
    # print(convert(7, 10, "445"))
    # print(convert(7, 10, "1026"))
    # print(convert(16, 7, "B48C03"))

    # print(fibo(301))
    # print(fibo_sum_evens(301))
    # print("The greatest palindrome that is the product of 2 three digit numbers:", max_elem(find_max(100, 999)))
    #
    # print("the factorial: ", fac(7))
    # print("n choose k: ", n_choose_k(12, 8))
    # print("n choose k: ", n_choose_k(40, 2))
    #
    # print("divisors of n: ", divisors(120))
    #
    # print(eratosthenes(20))
    #
    # start = timer()
    # x = prime_factorization1(2905962048)
    # end = timer()
    # print("prime factors of n: ", x, " it took: ", end - start, "seconds")
    # start = timer()
    # x = prime_factorization2(2905962048)
    # end = timer()
    # print("prime factors of n: ", x, " it took: ", end - start, "seconds")
    # start = timer()
    # x = prime_factorization2(600851475143)
    # end = timer()
    # print("prime factors of 600851475143: ", x, " performed in: ", end - start, "seconds")
    #
    # print(find_smallest_fit(20))
    # print(expand(find_smallest_fit(20)))
    #
    # testshit()
